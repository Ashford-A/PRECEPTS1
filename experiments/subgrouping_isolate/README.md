# Inferring the similarity of mutation subgroupings' downstream effects #

In this experiment we train mutation classifiers to predict the presence of
subsets of genes' mutations in a tumor cohort in three ways: "All", "Iso", and
"IsoShal". "All" is the same classification setup as in
`experiments.subgrouping_test`â€” the classifier uses all of the samples in the
cohort in an attempt to build a model that can predict the presence of a
particular type of mutation. In "Iso" and "IsoShal", we isolate the effect
of the mutation in question by removing potentially confounding samples from
the cohort before training the model. In particular, we remove (or "hold out")
samples carrying any mutation of the same gene as the subgrouping we are
trying to predict that do not belong to the subgrouping itself. In "Iso", this
includes all other point mutations of the gene as well as all copy number
alterations; in "IsoShal", this includes all other point mutations but only
"deep" CNAs as defined by GISTIC 2.0.

The "Iso" and "IsoShal" setups allow us to ask trained subgrouping classifiers
to make predictions on the held out samples to infer a similarity between
the subgrouping the classifier was trained on and the remaining mutations of
the gene. In the "All" setup, these remaining mutations would be included as
wild-types in the original subgrouping model, and thus the model would be
forced to treat them as distinct from the subgrouping. However, in our
isolation setups, the remaining mutations of the gene were not shown to the
subgrouping model during training, and thus the model is agnostic to whether
or not they are similar or different from the subgrouping. We can thus compare
the distribution of the predicted scores for the held out samples (or any
subset thereof, and especially subgroupings that do not overlap with the
original subgrouping) to the predicted scores of the wild-type samples and the
samples mutated for the original subgrouping. If the distribution is closer to
that of the wild-type samples, we can infer the held out samples (or the
subgrouping they belong to) is similar to the original subgrouping; if it is
closer to the original mutated samples we infer the held out samples are
similar in their transcriptomic profile to the samples affected by the
subgrouping.

We also define a new type of subgrouping (
`experiments.utilities.mutations.ExMcomb`) that represents the exclusive
presence of a subgrouping in the absence of another group of mutations
(`ExMcomb.all_mtype`). In particular, we define subgroupings where `all_mtype`
is all of the other mutations of the gene, as defined by the Iso and IsoShal
classification setups. These subgroupings are useful as they allow us to train
models to predict the downstream effect of a type of mutation when it appears
on its own, without the potentially confounding presence of another mutation
of the gene. For example, many point mutants of TP53 also carry a TP53
deletion, and `ExMcomb` allows us to create a subgrouping that only includes
the samples which carry a point mutant of TP53 but not a deep deletion. Note
that passing multiple mutation types using the `*mtypes` argument of `ExMcomb`
allows us to also create a subgrouping that includes the samples which carry
*both* a point mutation of TP53 and a deep deletion (but not those that only
carry one or the other, or any other mutation of TP53).

Please see the manuscript entitled "Characterizing the relationships within
the mutations of cancer genes using an inferred similarity metric" located at
our [Overleaf site](https://www.overleaf.com/project/6035bd54441f1ee82acb3f9b)
for a preliminary write-up of the results generated by this pipeline, and for
more discussion about the experiment setup and methodology.


## Preparing to run the experiment ##

Running this experiment is very similar to running the `subgrouping_test`
pipeline: clone the `dryads-research` repository, install the `research` conda
environment, create a Synapse config file, etc. If you have already completed
these steps to run `subgrouping_test`, you are set to run the pipeline
without any additional steps. Otherwise, see the "Preparing to run the
experiment" section of the `subgrouping_test` README.


## Running the experiment ##

Use `run_isolate.py` to launch the experiment pipeline, and modify
`cluster.json` if necessary which by default is designed for Slurm.

The arguments used by `run_isolate` are identical to those used by
`subgrouping_test.run_test.sh` with the exception of `search`, which replaces
`samp_cutoff`. In `subgrouping_test`, `samp_cutoff` specifies the minimum
number of cohort samples a subgrouping must appear in for it to be considered
by the pipeline, with all subgroupings consisting of at most two different
mutation types (i.e. mutation annotation levels, see
`dryads.features.mutations.branches` or the Methods section of the
`subgrouping_test` publication) each containing at least half the number of
`samp_cutoff` samples. Here, we specify different sets of possible subgrouping
enumeration criteria in `param_list.py`; the argument to `search` must
therefore be one of the keys of the dictionary defined in `param_list`.
Each entry of this dictionary is another dictionary with three entries:

- `samp_cutoff` The minimum number of samples the subgrouping must appear in.
- `branch_combs` The maximum number of mutation annotation levels a
                 subgrouping can contain. Thus a value of 1 only allows for
                 subgroupings like `PIK3CA:missense`, a value of 2 allows for
                 `PIK3CA:(missense or frameshift)`, and so on.
- `min_branch` How many samples each mutation annotation level a subgrouping
               is composed of must contain. This is redundant with
               `samp_cutoff` if `branch_combs` is equal to one. In the above
               example, if `min_branch` is set to 5, then for the subgrouping
               `PIK3CA:(missense or frameshift)` to be enumerated, there must
               be at least five cohort samples with PIK3CA missenses *and* at
               least five cohort samples with PIK3CA frameshifts.

The current version of the manuscript uses results generated using the
`semideep` combination of search parameters, and the Iso classification setup.


## Creating manuscript plots ##

The plots found in the current version of the manuscript are generated using
the following methods:

- **Figure 1** `plot_copy.plot_interaction_symmetries`
- **Figure 2A** `plot_copy.plot_point_similarity`
- **Figure 2B** `plot_copy.plot_similarity_symmetry`
- **Figure 3** `plot_point.plot_divergent_types`
- **Figure 4** `plot_points.plot_gene_synergy`

- **Figure S1** `plot_cluster.plot_clustering`
- **Figure S2** `plot_copy.plot_pair_scores`
- **Figure S3** `plot_similarities.plot_subcopy_adjacencies`
- **Figure S4** `plot_point.plot_divergent_pairs`
- **Figure S5** `plot_points.plot_overlap_aucs`

Please note that many of these plotting modules use a `--data_cache` argument.
To speed up the runtime of these scripts, create a cache by specifying a
`.zip` file for this argument the first time you run each script; specifying the
same file in subsequent runs will load the data from the cache.


## Calculating similarities ##

There are two methods used here to calculate the similarity of another
subgrouping (M2) to a subgrouping for which we have predicted task scores
(M1): "mean" and "ks". These are implemented in
`dryads-research.experiments.utilities.metrics`, and are invoked using the
`siml_fxs` mapping defined here under `utils`. The current version of the
manuscript relies solely on "ks", but "mean" gives similar results and is
useful for debugging purposes as it is faster to calculate.

Our goal is to place the predicted scores for samples mutated for M2 (S2) on
a spectrum between the predicted scores for samples mutated for M1 (S1) and
the scores for samples wild-type for any mutation of the gene in question
(WT). In particular, we want to generate a single number that describes
whether S2 is closer to S1 or to WT, that is, whether the subgrouping M2
resembles M1 in its downstream effects or not. The simplest way to do this is
to calculate the means of each of the three distributions WT, S1, and S2,
calculate the distance between the means of WT and S2, and then normalize it
using the distance between the means of WT and S1. Thus if the distributions
S1 and S2 are very similar, we will get a similarity score close to 1, and if
WT and S2 are very similar, we will get a similarity score close to 0.

However, we can use a method for determining the distance between each of our
distributions that is more sophisticated than using the distance between their
means. The two-sample Kolmogorov-Smirnov test compares two distributions and
calculates a statistic representing the confidence that one can reject the null
hypothesis that the two distributions are equal to one another. We use here
both one-sided versions of this test and subtract the statistic returned by
the "lesser" version from the statistic returned by the "greater" version to
generate a signed version of the K-S statistic. By calculating this signed K-S
statistic between all three pairs of WT, S1, and S2, we can thus "triangulate"
the position of S2 between S1 and WT.

We can thus calculate the similarity of M2 to M1, and if we have a subgrouping
task for M2, we can also calculate the similarity of M1 to M2. Note that even
if we do not have a task for M2, it can still be useful to compare it to M1 if
there are a sufficient number of samples mutated for M2. For example, in
`plot_point.plot_divergent_types`, we use our point mutation subgroupings as
M1, and the remaining point mutations of the same gene as M2. Even though we
do not have subgrouping tasks for M2 in this case, we can still consider the
distribution of scores returned by each M1 task for these remaining mutations,
as long as there are at least ten cohort samples carrying such mutations.
Remember that M1, by virtue of being a subgrouping enumerated by
`setup_isolate`, is guaranteed to have at least twenty mutated samples in the
cohort, or whatever threshold was specified using `param_list`.

We thus infer how divergent each subgrouping is from all of the other point
mutations of the gene. Compare this to `plot_point.plot_divergent_pairs`, in
which we consider similarities between pairs of explicitly-defined
subgroupings, each of which have predicted scores. This distinction between
explicitly and implicitly defined subgroupings occurs in other analyses as
well; see for instance `plot_copy`, in which we define a set of subgroupings
`proj_combs` for which we do not have classification tasks, but which
nevertheless appear in at least ten samples and can thus be compared to
subgroupings with predicted scores.
