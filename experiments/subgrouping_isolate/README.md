# Inferring the similarity of mutation subgroupings' downstream effects #

In this experiment we train mutation classifiers to predict the presence of
subsets of genes' mutations in a tumor cohort in three ways: "All", "Iso", and
"IsoShal". "All" is the same classification setup as in
`experiments.subgrouping_test`â€” the classifier uses all of the samples in the
cohort in an attempt to build a model that can predict the presence of a
particular type of mutation. In "Iso" and "IsoShal", we isolate the effect
of the mutation in question by removing potentially confounding samples from
the cohort before training the model. In particular, we remove (or "hold out")
samples carrying any mutation of the same gene as the subgrouping we are
trying to predict that do not belong to the subgrouping itself. In "Iso", this
includes all other point mutations of the gene as well as all copy number
alterations; in "IsoShal", this includes all other point mutations but only
"deep" CNAs as defined by GISTIC 2.0.

The "Iso" and "IsoShal" setups allow us to ask trained subgrouping classifiers
to make predictions on the held out samples to infer a similarity between
the subgrouping the classifier was trained on and the remaining mutations of
the gene. In the "All" setup, these remaining mutations would be included as
wild-types in the original subgrouping model, and thus the model would be
forced to treat them as distinct from the subgrouping. However, in our
isolation setups, the remaining mutations of the gene were not shown to the
subgrouping model during training, and thus the model is agnostic to whether
or not they are similar or different from the subgrouping. We can thus compare
the distribution of the predicted scores for the held out samples (or any
subset thereof, and especially subgroupings that do not overlap with the
original subgrouping) to the predicted scores of the wild-type samples and the
samples mutated for the original subgrouping. If the distribution is closer to
that of the wild-type samples, we can infer the held out samples (or the
subgrouping they belong to) is similar to the original subgrouping; if it is
closer to the original mutated samples we infer the held out samples are
similar in their transcriptomic profile to the samples affected by the
subgrouping.

We also define a new type of subgrouping (
`experiments.utilities.mutations.ExMcomb`) that represents the exclusive
presence of a subgrouping in the absence of another group of mutations
(`ExMcomb.all_mtype`). In particular, we define subgroupings where `all_mtype`
is all of the other mutations of the gene, as defined by the Iso and IsoShal
classification setups. These subgroupings are useful as they allow us to train
models to predict the downstream effect of a type of mutation when it appears
on its own, without the potentially confounding presence of another mutation
of the gene. For example, many point mutants of TP53 also carry a TP53
deletion, and `ExMcomb` allows us to create a subgrouping that only includes
the samples which carry a point mutant of TP53 but not a deep deletion. Note
that passing multiple mutation types using the `*mtypes` argument of `ExMcomb`
allows us to also create a subgrouping that includes the samples which carry
*both* a point mutation of TP53 and a deep deletion (but not those that only
carry one or the other, or any other mutation of TP53).

Please see the manuscript entitled "Characterizing the relationships within
the mutations of cancer genes using an inferred similarity metric" located at
our [Overleaf site](https://www.overleaf.com/project/6035bd54441f1ee82acb3f9b)
for a preliminary write-up of the results generated by this pipeline, and for
more discussion about the experiment setup and methodology.


## Preparing to run the experiment ##

Running this experiment is very similar to running the `subgrouping_test`
pipeline: clone the `dryads-research` repository, install the `research` conda
environment, create a Synapse config file, etc. If you have already completed
these steps to run `subgrouping_test`, you are set to run the pipeline
without any additional steps. Otherwise, see the "Preparing to run the
experiment" section of the `subgrouping_test` README.


## Running the experiment ##

Use `run_isolate.py` to launch the experiment pipeline, and modify
`cluster.json` if necessary which by default is designed for Slurm.

The arguments used by `run_isolate` are identical to those used by
`subgrouping_test.run_test.sh` with the exception of `search`, which replaces
`samp_cutoff`. In `subgrouping_test`, `samp_cutoff` specifies the minimum
number of cohort samples a subgrouping must appear in for it to be considered
by the pipeline, with all subgroupings consisting of at most two different
mutation types (i.e. mutation annotation levels, see
`dryads.features.mutations.branches` or the Methods section of the
`subgrouping_test` publication) each containing at least half the number of
`samp_cutoff` samples. Here, we specify different sets of possible subgrouping
enumeration criteria in `param_list.py`; the argument to `search` must
therefore be one of the keys of the dictionary defined in `param_list`.
Each entry of this dictionary is another dictionary with three entries:

- `samp_cutoff` The minimum number of samples the subgrouping must appear in.
- `branch_combs` The maximum number of mutation annotation levels a
                 subgrouping can contain. Thus a value of 1 only allows for
                 subgroupings like `PIK3CA:missense`, a value of 2 allows for
                 `PIK3CA:(missense or frameshift)`, and so on.
- `min_branch` How many samples each mutation annotation level a subgrouping
               is composed of must contain. This is redundant with
               `samp_cutoff` if `branch_combs` is equal to one. In the above
               example, if `min_branch` is set to 5, then for the subgrouping
               `PIK3CA:(missense or frameshift)` to be enumerated, there must
               be at least five cohort samples with PIK3CA missenses *and* at
               least five cohort samples with PIK3CA frameshifts.

The current version of the manuscript uses results generated using the
`semideep` combination of search parameters, and the Iso classification setup.
